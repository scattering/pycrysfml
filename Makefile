FORTCOMP=gfortran
ifeq ("$HOSTNAME", "darter"*)
FORTCOMP=ftn
endif
# Fortran 90 compilation.  This will vary depending on compiler.
# The -J Src option puts the mod files in the Src directory
Src/%.o: Src/%.f90; $(FORTCOMP) -c -g -Wall -fPIC -ffree-line-length-0 $< -o $@ -J Src

# Editting is currently happening on a different machine from compiling and running,
# hence the "copy" target
all: libcrysfml.so

# Dependencies are generated by ./f90_deps.py with the make deps target below
-include Makefile.deps

# Sources are listed in the Makefile.deps file
OBJECTS=$(SOURCES:.f90=.o)

# Override certain modules which are different on different architectures with the
# architecture specific version.  The last file on the ./f90_deps.py command line
# will be the one included in Sources.  The alternative would be to list all the
# files that are included (tedious) or excluded (better), but the technique below
# is simpler to specify and implement.
OVERRIDE=Src/CFML_ILL_Instrm_Data.f90 Src/CFML_GlobalDeps_Linux.f90 Src/CFML_IO_Mess.f90

# Copy program over from sparkle
copy:
	# The -p option should preserve the timestamp
	scp -pq sparkle:~/Pycrysfml/*.py .
	scp -pq sparkle:~/crysfml/Src/*.f90 Src

# Build the shared object file from the list of objects
libcrysfml.so: $(OBJECTS)
	$(FORTCOMP) -o libcrysfml.so -g -shared $(OBJECTS)

# Generate dependencies.  This needs to be rerun whenever a new module is added
# or a Use statement is updated.
deps:
	./f90_deps.py Src/*.f90 $(OVERRIDE) > Makefile.deps
clean:
	rm libcrysfml.so Src/*.o
install:
	cp libcrysfml.so ./Src/crysfml.so
